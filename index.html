<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>FlatJS - A simpler JS framework</title>

    <link rel="stylesheet" href="http://netdna.bootstrapcdn.com/bootstrap/3.1.1/css/bootstrap.min.css">
    <link rel="stylesheet" href="http://netdna.bootstrapcdn.com/bootswatch/3.1.1/yeti/bootstrap.min.css">
    <link rel="stylesheet" href="stylesheets/styles.css">

    <script src="http://google-code-prettify.googlecode.com/svn/loader/run_prettify.js"></script>

    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div id="sidebar">
      <div class="container">
        <div class="row">
          <header class="col-sm-3 col-xs-12 col-sm-push-9">
            <div class="page-header">
              <h1>FlatJS</h1>
            </div>
            <p>A simpler JS framework.</p>

            <p class="view"><a href="https://github.com/sankho/FlatJS">View the Project on GitHub <small>sankho/FlatJS</small></a></p>

            <ul>
              <li><a href="https://github.com/sankho/FlatJS/zipball/master">Download <strong>ZIP File</strong></a></li>
              <li><a href="https://github.com/sankho/FlatJS/tarball/master">Download <strong>TAR Ball</strong></a></li>
              <li><a href="https://github.com/sankho/FlatJS">View On <strong>GitHub</strong></a></li>
            </ul>
          </header>
        </div>
      </div>
    </div>
    <div class="container">
      <div class="row">
        <section class="col-sm-9 col-xs-12">

          <div class="page-header jumbotron small-top">
            <h1>Flat JS <small>A simpler JS framework</small></h1>
          </div>

          <p class="lead">A <span class="st">bundle of scripts</span> JS framework used by <a href="#">Sankho Mallik</a> on projects to organize client side JavaScript without imposing application structure. Look, no MVC!</p>

          <p>These are scripts which I can use to start any client side JS project. I wanted something with more structure than vanilla JS / jQuery, but felt closer to Ruby or PHP in terms of OOP programming. I also wanted something which would work with less changes made to traditional server side structure, which is to say less reliance on JS templating or CRUD based REST API's. Not to say these things aren't neat, but you don't always need them, and more importantly, they don't always save time.</p>

          <div class="page-header">
            <h2>FlatJS is composed of 3 central modules:</h2>
          </div>

          <p><a href="#" class="label label-info">FlatJS.ModuleRunner</a> - Triggers JS execution by scanning for data attribute values in the DOM. Solves a key problem of any JS application: how to target functional JS code on your HTML (regardless of how or where it was templated).</p>

          <p><a href="#" class="label label-info">FlatJS.Classy</a> - OOP like class behavoir with inheritance and private member functions. Used for JS functionality that doesn't interact with the DOM.</p>

          <p><a href="#" class="label label-info">FlatJS.Widget</a> - <a href="#" class="label label-warning">extends FlatJS.Classy</a> - A Widget pattern for extensible, DRY code meant to interact with the DOM.</p>

          <h4 class="page-header small-top">Optional sub modules are located <a href="#">here.</a></h4>
          <p>Browser window monitoring, pubsub messaging and more as they come.</p>

          <!-- <div class="row">
            <div class="col-xs-4">
              <div class="page-header">
                <h3>Alternatives</h3>
              </div>
              <p>Popular JS frameworks impose ideologies which may be appropriate for some applications, but not all.</p>
              <p>Maybe you don't want to write two model layers on the client and server; maybe you want to generate markup from the server and not the client.</p>
              <p>FlatJS helps make coding quicker, while allowing one to structure their application as they wish.</p>
            </div>
            <div class="col-xs-4">
              <div class="page-header">
                <h3>How</h3>
              </div>
              <p>By doing very little. FlatJS only assumes that you're coding for a web browser, and that you already have a good idea of how to code.</p>
              <p>FlatJS' core provides a module runner to abstract your JS from your markup, an OOP class system to write code which is reusable and readable, and a Widget pattern to help keep your app &amp the DOM in sync.</p>
            </div>
            <div class="col-xs-4">
              <div class="page-header">
                <h3>Who</h3>
              </div>
              <p>FlatJS is intended for anyone who writes client side JS applications. It has no dependencies and can work with any other JS libraries and frameworks.</p>
              <p>Written and maintained by <a href="http://sankho.github.io/">Sankho Mallik</a>, a web developer living and working in NYC.</p>
              <p>Any and all feedback as well as code contributions are welcome!</p>
            </div>
          </div> -->

          <!-- <div class="page-header">
            <h3>What FlatJS is Not</h3>
          </div>
          <h4>No MVC?</h4>
          <p>FlatJS does not provide any MVC abstractions. MVC and similiar architectures are fine and all - but not applicable 100% of the time to client side JS so FlatJS avoids it.</p>
          <p>Client side JS apps don't have a secure way to access a true filesystem or database (yet), so a model layer will only make sense some of the time, and most of the time force you to write two sets of model code - one for the server, and another for the client. Controllers would be nice, but without a standard prototcol like REST to wrap around, it's utility will also vary dramatically on the client side.</p>
          <br />
          <h4>No templating? What gives?</h4>
          <p>Client side templating is similiar to a client side application's codebase - they vary heavily depending on the requirements of the app. FlatJS provides / forces no templating middleware for you to feel free using server side OR client side templates to your choosing, or what fits the scenario best.</p>
 -->

          <div class="page-header">
            <h3>DOM contextual code execution = less bootstrap code.</h3>
          </div>

          <p class="lead">Run JS directed by data attributes on your markup.</p>
          <p>Reference functions in a data attribute as strings like you would in the console, optionally using dashes as camel case. You can reference multiple functions, just put a space between them. They will execute in the order given, and will pass the node the data-attribute is on to each function.</p>
          <p>You can later use the runner again on AJAX retrieved or JS generated markup to initialize sections of your app with one line of code. Access the returned value of your function within the DOM node making a single point of truth for your application's widgets accessible via the DOM.</p>
          <p>This allows FlatJS to be equally useful if your markup is generated on the server side or if you do client side templating, or both. Focus on writing code, not figuring out how or when to execute it. It also forces you to organize your code with namespaces, but allows you to define the application structure's abstractions however you'd like.</p>

          <h3 class="label label-info">FlatJS.ModuleRunner</h3>

          <div class="row">
            <div class="col-xs-8">
              <pre class="prettyprint">
&lt;div id="example-div" data-js-module="NS.example-module"&gt;
  ...
  ...
  ...
&lt;/div&gt;
              </pre>
            </div>
            <div class="col-xs-4">
              <h3><span class="glyphicon glyphicon-arrow-left"></span> Markup.</h3>
              <p class="small">Maybe the server generates it; maybe you did with JS. Who knows. When you want to run Javascript, just add a reference in the data-js-module attribute.</p>
            </div>
          </div>
          <h3 class="label label-info">FlatJS.ModuleRunner</h3>
          <div class="row">
            <div class="col-xs-8">
              <pre class="prettyprint">
&lt;script&gt;
  var NS = {

    exampleModule: function(node) {

      node.innerHTML = 'Code Injection';

      var string = 'if returned this object will be attached to the node';

      this.getString = function() {
        return string;
      }

      return this;
    }
  }
&lt;/script&gt;
              </pre>
            </div>
            <div class="col-xs-4">
              <h3><span class="glyphicon glyphicon-arrow-left"></span> Application Code.</h3>
              <p class="small">Structure JS however you want. The only requirement is your end function must accept one argument; the HTML node used to call the function.</p>
              <p class="small">The ModuleRunner by default calls JS functions with the <code>new</code> operator. This can be changed however you want in the options.</p>
              <p class="small">If your function returns anything, it will be attached to the node it was called on in an array called <code>jsModules</code>. See the next section for an example.</p>
            </div>
          </div>
          <h3 class="label label-info">FlatJS.ModuleRunner</h3>
          <div class="row">
            <div class="col-xs-8">
              <pre class="prettyprint">
&lt;script src="/js/FlatJS.ModuleRunner.js"&gt;&lt;/script&gt;

&lt;script&gt;
  var NS.runner = new FlatJS.ModuleRunner({
    init: false   // see other options in docs
  });

  // pass other DOM nodes to NS.runner.init later
  // to quickly run JS after AJAX calls etc.
  NS.runner.init(document);

  var div = document.getElementById('#example-div'),
      obj = div.jsModules['NS.example-module'];

  console.log(obj.getString()); 
  // ==> 'if returned this object will be attached to the node'
&lt;/script&gt;
              </pre>
            </div>
            <div class="col-xs-4">
              <h3><span class="glyphicon glyphicon-arrow-left"></span> Load the script, run your JS.</h3>
              <p class="small">Save the runner to your namespace so you can execute it after ajax calls. Pass any node you want instead of document to target only what you need.</p>
              <p class="small">As long as you can access the node via DOM functions, you can see what was returned when the function ran. Useful for returning instances of classes.</p>
              <p class="small">Read more about the <a href="#"><span class="label label-info">FlatJS.ModuleRunner</span> module here.</a></p>
            </div>
          </div>

          <div class="page-header">
            <h3>OOP behavoir for client side JS</h3>
          </div>

          <p class="lead">Class inheritance + private member methods. Extending <a href="#">John Resig's work.</a></p>

          <p>JS is a language where technically, you can do everything without a framework, but you'll drive yourself and other developers crazy maintaining your code.</p>

          <p>Classy is a simple class implentation which gives you a way to write code resembling more traditional OOP languages on the server, if you'd like. While Classy is somewhat opinionated, you don't need to use all it's features.</p>

          <h3 class="label label-info">FlatJS.Classy</h3>
          <div class="row">
            <div class="col-xs-8">
              <pre class="prettyprint">
&lt;script&gt;
  var NS = {};

  NS.exampleClass = FlatJS.Classy.extend({

    init: function(privateEyesBegin) {
      this.privateEyesBegin = privateEyesBegin;
    },

    getChorus: function() {
      return this.privateEyesBegin + ' Are Watching You';
    }

  });

  var x = new NS.exampleClass('Private Eyes, ');

  console.log(x.getChorus());
  // => 'Private Eyes, Are Watching You';
&lt;/script&gt;
              </pre>
            </div>
            <div class="col-xs-4">
              <h3><span class="glyphicon glyphicon-arrow-left"></span> Basic Class Behavoir.</h3>
              <p class="small">Call <code>FlatJS.Classy.extend</code> to start things off and pass it an object.</p>
              <p class="small">Define an <code>init</code> function on your object as an initializer which will accept arguments passed from your generated constructor.</p>
            </div>
          </div>
          <h3 class="label label-info">FlatJS.Classy</h3>
          <div class="row">
            <div class="col-xs-8">
              <pre class="prettyprint">
&lt;script&gt;

  var x = NS.exampleChild.extend({

    getChorus: function() {
      var str = this.getChorus._super.apply(this);

      return str = str + ', They See Your Every Move';
    }

  });

  var y = new NS.exampleChild('Private Eyes, ');

  console.log(y.getChorus());
  // => 'Private Eyes, Are Watching You, They See Your Every Move';
&lt;/script&gt;
              </pre>
            </div>
            <div class="col-xs-4">
              <h3><span class="glyphicon glyphicon-arrow-left"></span> Class Inheritance.</h3>
              <p class="small">All <code>FlatJS.Classy</code> objects have an extend function to create children classes.</p>
              <p class="small">If you choose to override a function, you may access it's parent via the attached ._super function.</p>
              <p class="small">If you're familiar with the Resig link above, all this shouldn't be new to you.</p>
            </div>
          </div>
          <h3 class="label label-info">FlatJS.Classy</h3>
          <div class="row">
            <div class="col-xs-8">
              <pre class="prettyprint">
&lt;script src="/js/FlatJS.ModuleRunner.js"&gt;&lt;/script&gt;

&lt;script&gt;
  var NS.exampleModule = (function() {

    var STATIC_STRING            = 'Peas, ';

    var exampleModule = FlatJS.Classy.extend({

      init: function(string) {
        this.endString = string;
      },

      publicFnGetString: function() {
        // call method in scope privately
        this._(privateFnGetString)('Apples ,')
      }
    });

    // private member function - notice "this"
    function privateFnGetString(string) {
      return STATIC_STRING + string + this.endString;
    }

    return exampleModule;
  }());

  var x = new NS.exampleModule('Carrots');

  console.log(x.getString()); 
  // ==> 'Peas, Apples, and Carrots';
&lt;/script&gt;
              </pre>
            </div>
            <div class="col-xs-4">
              <span class="label label-danger">Dogma Alert</span>
              <h3><span class="glyphicon glyphicon-arrow-left"></span> Private Member Functions.</h3>
              <p class="small">Javascript by nature doesn't discern between public and private methods when dealing with objects, unless you're willing to resort to var self = this hacks, so I made an apply wrapper in a function called _.</p>
              <p class="small">This is mostly useless sugar so I've placed a "dogma alert" above to call me on my own bullshit.</p>
              <p class="small">The key bit of code is in the getString() function, which is public. It calls the privateFnGetString by wrapping it in the _ function, then passing arguments to it while executing it.</p>
              <p class="small">If you look at the private code executed, you will see it does the work and can access the member object for whatever information is available.</p>
              <p class="small">Again, this is mostly just to keep your code uniform, but will force you to consider what functions are best to keep public and private, all while keeping "this" consistent.</p>
              <p class="small">Read more about the <a href="#"><span class="label label-info">FlatJS.Classy</span> module here.</a></p>
            </div>
          </div>

          <div class="page-header">
            <h3>A reliable client side widget pattern</h3>
          </div>

          <p class="lead">Maybe you call them components. Maybe you call them widgets.</p>

          <p>Developing apps for web browsers invariably means you'll have JS that can be scoped and targeted to HTML. FlatJS provides a simple pattern representing the lifecyle of these widgets, which include initializing, rendering, binding JS events, syncing and destroying itself when needed. Based on <a href="#">YUI3 Base Widget.</a></p>

          <p>FlatJS Widgets are constructor functions once created, and require one argument on initialization: a single DOM node. By default instatiating a Widget class creates an object and runs a <code>.render()</code> function which by default triggers a four function sequence, firing <code>.initialize(), .renderUI(), .bindUI(), and .syncUI()</code> in succession.</p>

          <p><a class="label label-info">FlatJS.Widget</a> is an extension of <a class="label label-info">FlatJS.Classy</a> and thus shares all of it's behavoir. In fact, you create Widgets by calling <code>FlatJS.Widget.extend()</code> So, all your widgets are extensible as classes would be, and all of the above functions are defined by the object you pass when extending FlatJS.Widget. See below.</p> 

          <h3 class="label label-info">FlatJS.Widget</h3>

          <!-- <div class="page-header">
            <h3>What's included in FlatJS?</h3>
          </div>
          <p class="lead">FlatJS is composed of three base modules to aid in the following:</p>

          <ol>
            <li>Programmatic execution of JS on DOM elements agnostic of how the DOM elements are generated. - <a href="#" class="label label-info">FlatJS.ModuleRunner</a></li>
            <li>Giving JS basic OOP like behavoir, including private member functions and inheritance. - <a href="#" class="label label-info">FlatJS.Classy</a></li>
            <li>Providing an app lifecycle to JS code based on DOM interactions. - <a href="#" class="label label-info">FlatJS.Widget</a> <a href="#" class="label label-warning">req. FlatJS.Classy</a></li>
          </ol>

          <p>And several optional modules to aid in certain cases:</p>

          <ol>
            <li>Inter module pubsub messaging - <a href="#" class="label label-info">FlatJS.Dispatch</a> <a href="#" class="label label-warning">req. FlatJS.Widget</a> <a href="#" class="label label-default">extends FlatJS.Widget.prototype</a></li>
            <li>Window / browser monitoring, resize, scroll, more - <a href="#" class="label label-info">FlatJS.WindowMonitor</a> <a href="#" class="label label-warning">req. FlatJS.Widget</a></li>
            <li>More as I make em.</li>
          </ol> -->

          <div class="page-header">
            <h3>But really, why?</h3>
          </div>

          <p class="lead">A: Because the current crop of JS frameworks aren't simple enough.</p>

          <p>I don't want an abstraction layer that forces me to write more code to keep up with the abstractions it's imposing on me. Nor do I believe any high level ideologies apply easily to client side JS - mainly MV*.</p>

          <p>But what I DO want is something which saves me time by taking away trivial, but common JS tasks. Having a reliable way to execute JS code on markup, being able to program with inheritance in mind, and having an app lifecycle for JS that deals with markup - these are things I'll almost definitely need on any client side JS project.</p>

          <p>JS is a simple language and part of what makes it great is the developer's freedom in being able to structure their application's abstractions according to what the application needs. FlatJS tries to provide a framework that never gets in the way.</p>

          <p>But this is all just my opinion, and in the end is just some code I've used for projects and will continue to do so personally. This website serves as a home for the project.</p>

        </section>
      </div>
      <div class="row">
        <footer class="col-xs-12">
          <div class="panel">
            <p>This project is maintained by <a href="https://github.com/sankho">sankho</a></p>
            <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
          </div>
        </footer>
      </div>
    </div>

    <script src="src/FlatJS.ModuleRunner.js"></script>
    <script src="src/FlatJS.Classy.js"></script>
    <script src="src/FlatJS.Widget.js"></script>
    
    <script>
      var FJS = {};

      FJS.ModuleRunner = new FlatJS.ModuleRunner({
        context: FJS
      });
    </script>

  </body>
</html>